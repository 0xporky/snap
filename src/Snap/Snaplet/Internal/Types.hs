{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE BangPatterns               #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeOperators              #-}
{-# LANGUAGE NoMonomorphismRestriction  #-}
{-# LANGUAGE RankNTypes                 #-}

module Snap.Snaplet.Internal.Types where

import           Prelude hiding ((.))
import           Control.Applicative
import           Control.Category ((.))
import           Control.Monad.CatchIO hiding (Handler)
import           Control.Monad.Reader
import           Control.Monad.State.Class
import           Control.Monad.Trans.Writer hiding (pass)
import           Data.ByteString (ByteString)
import qualified Data.ByteString.Char8 as B
import           Data.Configurator.Types
import           Data.IORef
import           Data.Monoid
import           Data.Record.Label
import           Data.Text (Text)
import qualified Data.Text as T

import           Snap.Snaplet.Internal.Lens
import           Snap.Types


data SnapletConfig = SnapletConfig
    { _scAncestry        :: [Text]
    , _scFilePath        :: FilePath
    , _scId              :: Maybe Text
    , _scDescription     :: Text
    , _scUserConfig      :: Config
    , _scRouteContext    :: [ByteString]
    , _reloader          :: IO (Either String String) -- might change
    }


------------------------------------------------------------------------------
-- | Joins a reversed list of directories into a path.
buildPath :: [ByteString] -> ByteString
buildPath ps = B.intercalate "/" $ reverse ps


------------------------------------------------------------------------------
-- | Snaplet's type parameter 's' here is user-defined and can be any Haskell
-- type.  A value of type @Snaplet Foo@ countains a couple of things:
--
-- * a value of type @Foo@, called the \"user state\".
--
-- * some bookkeeping data the framework uses to plug things together, like the
--   snaplet's configuration, the snaplet's root directory on the filesystem,
--   the snaplet's root URL, and so on.
data Snaplet s = Snaplet
    { _snapletConfig :: SnapletConfig
    , _value         :: s
    }


instance Functor Snaplet where
    fmap f (Snaplet c v) = (Snaplet c (f v))


mkLabels [''SnapletConfig, ''Snaplet]


------------------------------------------------------------------------------
-- | A lens to get the user defined state out of a Snaplet.
snapletValue :: Snaplet a :-> a
snapletValue = value


------------------------------------------------------------------------------
-- | Transforms a lens of the type you get from mkLabels to an similar lens
-- that is more suitable for internal use.
subSnaplet :: (a :-> Snaplet b) -> (Snaplet a :-> Snaplet b)
subSnaplet = (. value)


------------------------------------------------------------------------------
-- | Minimal complete definition:
--
-- * 'withBase', 'withChild', and all of the getXYZ functions.
--
class MonadSnaplet m where
    -- | Takes a snaplet action where the current snaplet is the same as the
    -- base snaplet and runs it in the context of any child snaplet e.
    withBase :: m b b a -> m b e a
    --withBase = withSibling id

    -- | Runs a child snaplet action in a parent snaplet's monad.  The
    -- supplied lens defines the state type to use.
    withChild :: (e :-> Snaplet e') -> m b e' a -> m b e a
    withChild = withChild' . subSnaplet

    -- | Like 'withChild' but doesn't impose the requirement that the action
    -- being run be a descendant of the current snaplet.
    withSibling :: (b :-> Snaplet e') -> m b e' a -> m b e a
    withSibling l = withSibling' (subSnaplet l)

    -- | A variant of withChild accepting another kind of lens formulation
    -- that has an identity.  The lenses generated by 'mkLabels' will not
    -- work with this function, however the lens returned by 'getLens' will.
    --
    -- @withChild = withChild' . subSnaplet@
    withChild' :: (Snaplet e :-> Snaplet e') -> m b e' a -> m b e a

    -- Not providing a definition for this function in terms of withSibling'
    -- allows us to avoid extra Monad type class constraints, making the type
    -- signature easier to read.
    -- withChild' l m = flip withSibling m . (l .) =<< getLens

    -- | The sibling version of 'withChild''
    withSibling' :: (Snaplet b :-> Snaplet e') -> m b e' a -> m b e a
    withSibling' l = withBase . withChild' l

    -- | Gets the lens for the current snaplet.
    getLens :: m b e (Snaplet b :-> Snaplet e)

    -- | Gets a list of the names of snaplets that are direct ancestors of the
    -- current snaplet.
    getSnapletAncestry :: m b e [Text]

    -- | Gets the snaplet's path on the filesystem.
    getSnapletFilePath :: m b e FilePath

    -- | Gets the current snaple's name.
    getSnapletName :: m b e (Maybe Text)

    -- | Gets the current snaple's name.
    getSnapletDescription :: m b e Text

    -- | Gets the config data structure for the current snaplet.
    getSnapletConfig :: m b e Config

    -- | Gets the base URL for the current snaplet.  Directories get added to
    -- the current snaplet path by calls to `nestSnaplet`.
    getSnapletRootURL :: m b e ByteString


{-
wrap :: (MonadSnaplet m, Monad (m b b), Monad (m b e'))
     => ((Snaplet e' :-> Snaplet e) -> m b e a -> m b e' a)
     -> (Snaplet e' :-> Snaplet e)
     -> (m b e a -> m b e a)
     -> m b e' a
     -> m b e' a
-}
wrap :: (MonadSnaplet m, Monad (m b b), Monad (m b e'))
     => (m b e  a -> m b e' a)
     -> (m b e  a -> m b e  a) -> (m b e' a -> m b e' a)
wrap proj _filter m = do
    currentLens <- getLens
    proj (_filter (withSibling' currentLens m))

------------------------------------------------------------------------------
-- | Applies a "filter" style function on snaplet monads with a descendent
-- snaplet.
wrapChild :: (MonadSnaplet m, Monad (m b b), Monad (m b e'))
          => (Snaplet e' :-> Snaplet e)
          -> (m b e  a -> m b e  a)
          -> (m b e' a -> m b e' a)
wrapChild l = wrap (withChild' l)


------------------------------------------------------------------------------
-- | Applies a "filter" style function on snaplet monads with a sibling
-- snaplet.
wrapSibling :: (MonadSnaplet m, Monad (m b b), Monad (m b e'))
            => (Snaplet b :-> Snaplet e)
            -> (m b e  a -> m b e  a)
            -> (m b e' a -> m b e' a)
wrapSibling l = wrap (withSibling' l)


------------------------------------------------------------------------------
newtype Handler b e a =
    Handler (LensT (Snaplet b) (Snaplet e) (Snaplet b) Snap a)
  deriving ( Monad
           , Functor
           , Applicative
           , MonadIO
           , MonadPlus
           , MonadCatchIO
           , Alternative
           , MonadSnap)


-- It's looking like we won't need these.
-- TODO If they're not being used, take them out before release.
type family Base (m :: * -> *) :: *
type family Env (m :: * -> *) :: *


hConfig :: Handler b e SnapletConfig
hConfig = Handler $ liftM _snapletConfig get


instance MonadSnaplet Handler where
    getLens = Handler ask
    withBase (Handler m) = Handler $ downcast m
    withChild' !l (Handler !m) = Handler $ withLens l m
    getSnapletAncestry = return . _scAncestry =<< hConfig
    getSnapletFilePath = return . _scFilePath =<< hConfig
    getSnapletName = return . _scId =<< hConfig
    getSnapletDescription = return . _scDescription =<< hConfig
    getSnapletConfig = return . _scUserConfig =<< hConfig
    getSnapletRootURL = do
        ctx <- liftM _scRouteContext hConfig
        return $ buildPath ctx


------------------------------------------------------------------------------
-- | Handler that reloads the site.
reloadSite :: Handler b e ()
reloadSite = failIfNotLocal $ do
    cfg <- hConfig
    !res <- liftIO $ _reloader cfg
    either bad good res
  where
    bad msg = do
        writeText $ "Error reloading site!\n\n"
        writeText $ T.pack msg
    good msg = do
        writeText $ T.pack msg
        writeText $ "Site successfully reloaded.\n"
    failIfNotLocal m = do
        rip <- liftM rqRemoteAddr getRequest
        if not $ elem rip [ "127.0.0.1"
                          , "localhost"
                          , "::1" ]
          then pass
          else m


------------------------------------------------------------------------------
-- | Information about a partially constructed initializer.  Used to
-- automatically aggregate handlers and cleanup actions.
data InitializerState b = InitializerState
    { _isTopLevel      :: Bool
    , _cleanup         :: IO ()
    , _handlers        :: [(ByteString, Handler b b ())]
    -- ^ Handler routes built up and passed to route.
    , _hFilter         :: Handler b b () -> Handler b b ()
    -- ^ Generic filtering of handlers
    , _curConfig       :: SnapletConfig
    -- ^ This snaplet config is the incrementally built config for whatever
    -- snaplet is currently being constructed.
    , _initMessages    :: IORef Text
    }


------------------------------------------------------------------------------
-- | Wrapper around IO actions that modify state elements created during
-- initialization.
newtype Hook a = Hook (Snaplet a -> IO (Snaplet a))


instance Monoid (Hook a) where
    mempty = Hook return
    (Hook a) `mappend` (Hook b) = Hook (a >=> b)


------------------------------------------------------------------------------
-- | Monad used for initializing snaplets.
newtype Initializer b e a = 
    Initializer (LensT (Snaplet b)
                       (Snaplet e)
                       (InitializerState b)
                       (WriterT (Hook b) IO)
                       a)
  deriving (Applicative, Functor, Monad, MonadIO)

mkLabels [''InitializerState]


iConfig :: Initializer b e SnapletConfig
iConfig = Initializer $ liftM _curConfig getBase


instance MonadSnaplet Initializer where
    getLens = Initializer ask
    withBase (Initializer m) = Initializer $ downcast m
    withChild' !l (Initializer !m) = Initializer $ withLens l m

    getSnapletAncestry = return . _scAncestry =<< iConfig
    getSnapletFilePath = return . _scFilePath =<< iConfig
    getSnapletName = return . _scId =<< iConfig
    getSnapletDescription = return . _scDescription =<< iConfig
    getSnapletConfig = return . _scUserConfig =<< iConfig
    getSnapletRootURL = do
        ctx <- liftM _scRouteContext iConfig
        return $ buildPath ctx


------------------------------------------------------------------------------
-- | Information needed to reload a site.  Instead of having snaplets define
-- their own reload actions, we store the original site initializer and use it
-- instead.
data ReloadInfo b = ReloadInfo
    { riRef     :: IORef (Snaplet b)
    , riAction  :: Initializer b b b
    }


------------------------------------------------------------------------------
instance MonadState e (Handler b e) where
    get = liftM _value lhGet
    put v = do
        s <- lhGet
        lhPut $ s { _value = v }

lhGet :: Handler b e (Snaplet e)
lhGet = Handler get
{-# INLINE lhGet #-}

lhPut :: Snaplet e -> Handler b e ()
lhPut = Handler . put
{-# INLINE lhPut #-}

