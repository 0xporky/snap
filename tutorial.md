# What Are Snaplets?

Snaplets allow you to build web applications out of composable parts. This
lets you to build self-contained units and glue them together to make your
overall application. Here are some of the things provided by the snaplet
infrastructure:

  - Infrastructure for application state/environment
  
  - Snaplet initialization, reload, and cleanup
  
  - Management of filesystem data and automatic snaplet installation
  
  - Unified config file infrastructure


# Snaplet Overview

A snaplet is a web application, and web applications are snaplets. This means
that using snaplets and writing snaplets are almost the same thing.

The heart of the snaplets infrastructure is state management. Most nontrivial
pieces of a web app need some kind of state or environment data. Components
that do not need any kind of state or environment are probably more appropriate
as a standalone library than as a snaplet.

Before we continue, we must clarify an important point. The Snap web server
processes each request in its own green thread. This means that each request
will receive a separate copy of the state defined by your application and
snaplets, and modifications to that state only affect the local thread. If you
need global application state, you have to use a thread-safe construct such as
an MVar.

We start our application by defining a data structure to hold the state. This
data structure includes the state of any snaplets (wrapped in a Snaplet) we
want to use as well as any other state we might want.

    module MyApp where
    import Snap.Snaplet
    import Snap.Snaplet.Heist

    data App = App
        { _heist       :: Snaplet (Heist App)
        , _foo         :: Snaplet Foo
        , _bar         :: Snaplet Bar
        , _companyName :: String
        }

    mkLabels [''App]

The field names begin with an underscore because of some more complicated
things going on under the hood. However, all you need to know right now is that
you should prefix things with an underscore and then call mkLabels. This lets
you use the names without an underscore in the rest of your application.

The next thing we need to do is define an initializer.

    app :: Initializer App App App
    app = do
        hs <- nestSnaplet "heist" $ heistInit "templates"
        fs <- nestSnaplet "foo" $ fooInit heist
        bs <- nestSnaplet "" $ nameSnaplet "baz" $ barInit heist
        addRoutes [ ("/hello", writeText "hello world")
                  ]
        wrapHandlers (<|> with heist heistServe)
        return $ App hs fs bs "fooCorp"

For now don't worry about the three type parameters to Initializer. We'll
discuss them in more detail later. The basic idea here is that to initialize an
application, we first initialize each of the snaplets, add some routes, run a
function wrapping all the routes, and return the resulting state data
structure. This example demonstrates the use of a few of the most common
snaplet functions.

    nestSnaplet :: ByteString -> Initializer b v a -> Initializer b v a

All calls to child snaplet initializer functions must be wrapped in a call to
nestSnaplet. The first parameter is a URL path segment that is used to prefix
all routes defined by the snaplet. This lets you ensure that there will be no
problems with duplicate routes defined in different snaplets. If the foo
snaplet defines a route /foopage, then in the above example, that page will be
available at /foo/foopage. Sometimes though, you might want a snaplet's routes
to be available at the top level. To do that, just pass an empty string to
nestSnaplet as shown above with the bar snaplet.

In our example above, the foo snaplet does something that needs to know about
the Heist snaplet. Maybe it wants to add its own templates or bind some
splices. In order to make that happen, it needs to have a "handle" to the Heist
snaplet. Our handles are whatever field names we used in the App data structure
minus the initial underscore character. They are automatically generated by the
mkLabels function and will be discussed in more detail later. For now it's
sufficient to think of them as a getter and a setter combined (to use an OO
metaphor).

    nameSnaplet :: Text -> Initializer b v (Snaplet a) -> Initializer b v (Snaplet a)

Snaplets usually define a default name used to identify the snaplet. This name
is used for the snaplet's directory in the filesystem. If you don't want to use
the default name, you can override it with the nameSnaplet function. Also, if
you want to have two instances of the same snaplet, then you will need to use
nameSnaplet to give at least one of them a unique name.

    addRoutes :: [(ByteString, Handler b b ())] -> Initializer b v ()

The addRoutes function is how an application (or snaplet) defines its routes.
Under the hood the snaplet infrastructure merges all the routes from all
snaplets, prepends prefixes from nestSnaplet calls, and passes the list to
Snap's
[route](http://hackage.haskell.org/packages/archive/snap-core/0.5.1.4/doc/html/Snap-Types.html#v:route)
function. This gives us the first introduction to Handler, the other main data
type defined by the snaplet infrastructure. During initialization, snaplets use
the Initializer monad. During runtime, snaplets use the Handler monad. We'll
discuss Handler in more detail later. If you're familiar with Snap's old
extension system, you can think of it as roughly equivalent to the Application
monad. It has a MonadState instance that lets you access and modify the current
snaplet's state, and a MonadSnap instance providing the request-processing
functions defined in Snap.Types.

    wrapHandlers :: (Handler b b () -> Handler b b ()) -> Initializer b v ()

wrapHandlers allows you to apply an arbitrary Handler transformation to the
top-level handler. This is useful if you want to do some generic processing at
the beginning or end of every request. For instance, a session snaplet might
use it to touch a session activity token at the beginning of every request. It
could also be used to implement custom logging. The example above uses it to
define heistServe as the default handler to be tried if no other handler
matched. This example is easy to understand, but defining routes in this way
gives O(n) time complexity, whereas routes defined with addRoutes have O(log n)
time complexity. In a real-world application you would probably want to have
("", with heist heistServe) in the list passed to addRoutes.

The last unfamiliar function in the example is with. To understand it, we need
to look at heistServe's type signature:

    heistServe :: Handler b (Heist b) ()

This type signature isn't quite what the type checker will tell you, but it
communicates the basic concept. "Handler b v" is the runtime monad for
snaplets. The type parameter 'b' is the base state type for the application.
The type parameter v defines the snaplet currently in view. Handler's
MonadState instance gives it access to the current context (the 'v'), which is
why the Heist snaplet provides heistServe with the above (approximate) type
signature. The addRoutes and wrapHandlers functions require handlers where the
current context is the top-level application. The with function transforms a
snaplet handler from a lower context to a higher context. But in order to do
this, you have to know how to get from the higher context to the lower
context, so you have to pass "heist" as the first parameter to with.

This might seem a bit onerous at first glance, but in the general case it's
absolutely necessary. For example, what if you had multiple heist snaplet
instances in a single application. Calls to API functions provided by the heist
snaplet would have to know which instance to use. The lenses created by
mkLabels have all the information needed for this. If you know that you will
only ever have one instance of a particular snaplet, you can get around this
issue with techniques that we will describe later.

This notion of transforming current contexts to and from base and child types
is encapsulated in the MonadLens type class. Both the Initializer and Handler
monads have MonadLens instances. This allows you to navigate the snaplet
hierarchy in both monads using the same lenses.


# Writing Snaplets

